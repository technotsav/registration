<!--<!DOCTYPE html>
<html lang="en" class="no-js">

<head>
    <title>Technotsav'24</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" crossorigin="anonymous">
    <script type="text/javascript" src="js/index.js"></script>
    <script type="text/javascript" src="js/main_animation.js"></script>
</head>

<body>
    <div id="animations">
        <div id="main_body" class="body_class">
            <h1 style="font-family: 'Roboto', sans-serif; font-style: initial;">Technotsav</h1>
            <h2 class="desc" style="font-weight: 10; font-size: 20px;">
                Join us to 
                <span class="text-switcher" style="font-style: initial; font-size: 22px;" data-hold-time="1000" data-switch-content='[ "Invent.", "Ignite.","Paradox.","Dance.","Game."]'></span>
            </h2>
            <hr style="width: 50%; background-color: #1D2951; border-color: #1D2951;">
            <!-- <a href="https://instagram.com/" style="color: white;"><i class="fab fa-instagram" style="font-size: 2em;"></i></a> &nbsp  -->
            <!-- <a href="https://github.com/" style="color: white;"><i class="fab fa-github" style="font-size: 2em;"></i></a> &nbsp -->

      <!--  </div> 
    </div>
</body>

</html> -->


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Particles</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');
html, body { 
  
  margin: 0;
  height: 100%;
  overflow: hidden;
  font-family: 'Roboto' !important; 
  color: white;
  font-size: 4px;
}

#magic {

  position: fixed;
  width: 100%;
  height: 100vh;
  display: block;
  top: 0;
  left: 0;
  z-index: -9999;
}

.playground{

  position: fixed;
  width: 100%;
  height: 100vh;
  display: block;
  top: 0;
  left: 0;
  display: flex;
  flex-wrap: nowrap;
  flex-direction: column;
  justify-content: flex-end;
  align-items: center;

}
.bottomPosition{

  text-align: center;
  margin-bottom: 50px;
  
}
.minText{
  
  font-size: 4px;
}

a {
  color: white;
  font-size: 12px;
  text-decoration: none;
}

.logo {
    width: 50px;
    height: 50px;
}
  </style>
</head>
<body>
  <script type="x-shader/x-vertex" id="vertexshader">

  attribute float size;
  attribute vec3 customColor;
  varying vec3 vColor;

  void main() {

    vColor = customColor;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_PointSize = size * ( 300.0 / -mvPosition.z );
    gl_Position = projectionMatrix * mvPosition;

  }

</script>
<script type="x-shader/x-fragment" id="fragmentshader">

 uniform vec3 color;
 uniform sampler2D pointTexture;

 varying vec3 vColor;

 void main() {

   gl_FragColor = vec4( color * vColor, 1.0 );
   gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

 }
</script>

<div id="magic"></div>
<div class="playground">
  <div class="bottomPosition">
     
        <h1 class="special">Joel Sanjay <br><span class="minText">many things.</span></h1>
  </div>
</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    (function(window, document) {
    "use strict";
    var pluginName = 'particleground';

    function extend(out) {
        out = out || {};
        for (var i = 1; i < arguments.length; i++) {
            var obj = arguments[i];
            if (!obj) continue;
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (typeof obj[key] === 'object')
                        deepExtend(out[key], obj[key]);
                    else
                        out[key] = obj[key];
                }
            }
        }
        return out;
    };

    var $ = window.jQuery;

    function Plugin(element, options) {
        var canvasSupport = !!document.createElement('canvas').getContext;
        var canvas;
        var ctx;
        var particles = [];
        var raf;
        var mouseX = 0;
        var mouseY = 0;
        var winW;
        var winH;
        var desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
        var orientationSupport = !!window.DeviceOrientationEvent;
        var tiltX = 0;
        var pointerX;
        var pointerY;
        var tiltY = 0;
        var paused = false;

        options = extend({}, window[pluginName].defaults, options);

        /**
         * Init
         */
        function init() {
            if (!canvasSupport) { return; }

            //Create canvas
            canvas = document.createElement('canvas');
            canvas.className = 'pg-canvas';
            canvas.style.display = 'block';
            element.insertBefore(canvas, element.firstChild);
            ctx = canvas.getContext('2d');
            styleCanvas();

            // Create particles
            var numParticles = Math.round((canvas.width * canvas.height) / options.density);
            for (var i = 0; i < numParticles; i++) {
                var p = new Particle();
                p.setStackPos(i);
                particles.push(p);
            };

            window.addEventListener('resize', function() {
                resizeHandler();
            }, false);

            document.addEventListener('mousemove', function(e) {
                mouseX = e.pageX;
                mouseY = e.pageY;
            }, false);

            if (orientationSupport && !desktop) {
                window.addEventListener('deviceorientation', function() {
                    // Contrain tilt range to [-30,30]
                    tiltY = Math.min(Math.max(-event.beta, -30), 30);
                    tiltX = Math.min(Math.max(-event.gamma, -30), 30);
                }, true);
            }

            draw();
            hook('onInit');
        }

        /**
         * Style the canvas
         */
        function styleCanvas() {
            canvas.width = element.offsetWidth;
            canvas.height = element.offsetHeight;
            ctx.fillStyle = options.dotColor;
            ctx.strokeStyle = options.lineColor;
            ctx.lineWidth = options.lineWidth;
        }

        /**
         * Draw particles
         */
        function draw() {
            if (!canvasSupport) { return; }

            winW = window.innerWidth;
            winH = window.innerHeight;

            // Wipe canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update particle positions
            for (var i = 0; i < particles.length; i++) {
                particles[i].updatePosition();
            };
            // Draw particles
            for (var i = 0; i < particles.length; i++) {
                particles[i].draw();
            };

            // Call this function next time screen is redrawn
            if (!paused) {
                raf = requestAnimationFrame(draw);
            }
        }

        /**
         * Add/remove particles.
         */
        function resizeHandler() {
            // Resize the canvas
            styleCanvas();

            var elWidth = element.offsetWidth;
            var elHeight = element.offsetHeight;

            // Remove particles that are outside the canvas
            for (var i = particles.length - 1; i >= 0; i--) {
                if (particles[i].position.x > elWidth || particles[i].position.y > elHeight) {
                    particles.splice(i, 1);
                }
            };

            // Adjust particle density
            var numParticles = Math.round((canvas.width * canvas.height) / options.density);
            if (numParticles > particles.length) {
                while (numParticles > particles.length) {
                    var p = new Particle();
                    particles.push(p);
                }
            } else if (numParticles < particles.length) {
                particles.splice(numParticles);
            }

            // Re-index particles
            for (i = particles.length - 1; i >= 0; i--) {
                particles[i].setStackPos(i);
            };
        }

        /**
         * Pause particle system
         */
        function pause() {
            paused = true;
        }

        /**
         * Start particle system
         */
        function start() {
            paused = false;
            draw();
        }

        /**
         * Particle
         */
        function Particle() {
            this.stackPos;
            this.active = true;
            this.layer = Math.ceil(Math.random() * 3);
            this.parallaxOffsetX = 0;
            this.parallaxOffsetY = 0;
            // Initial particle position
            this.position = {
                    x: Math.ceil(Math.random() * canvas.width),
                    y: Math.ceil(Math.random() * canvas.height)
                }
                // Random particle speed, within min and max values
            this.speed = {}
            switch (options.directionX) {
                case 'left':
                    this.speed.x = +(-options.maxSpeedX + (Math.random() * options.maxSpeedX) - options.minSpeedX).toFixed(2);
                    break;
                case 'right':
                    this.speed.x = +((Math.random() * options.maxSpeedX) + options.minSpeedX).toFixed(2);
                    break;
                default:
                    this.speed.x = +((-options.maxSpeedX / 2) + (Math.random() * options.maxSpeedX)).toFixed(2);
                    this.speed.x += this.speed.x > 0 ? options.minSpeedX : -options.minSpeedX;
                    break;
            }
            switch (options.directionY) {
                case 'up':
                    this.speed.y = +(-options.maxSpeedY + (Math.random() * options.maxSpeedY) - options.minSpeedY).toFixed(2);
                    break;
                case 'down':
                    this.speed.y = +((Math.random() * options.maxSpeedY) + options.minSpeedY).toFixed(2);
                    break;
                default:
                    this.speed.y = +((-options.maxSpeedY / 2) + (Math.random() * options.maxSpeedY)).toFixed(2);
                    this.speed.x += this.speed.y > 0 ? options.minSpeedY : -options.minSpeedY;
                    break;
            }
        }

        /**
         * Draw particle
         */
        Particle.prototype.draw = function() {
            // Draw circle
            ctx.beginPath();
            ctx.arc(this.position.x + this.parallaxOffsetX, this.position.y + this.parallaxOffsetY, options.particleRadius / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();

            // Draw lines
            ctx.beginPath();
            // Iterate over all particles which are higher in the stack than this one
            for (var i = particles.length - 1; i > this.stackPos; i--) {
                var p2 = particles[i];

                // Pythagorus theorum to get distance between two points
                var a = this.position.x - p2.position.x
                var b = this.position.y - p2.position.y
                var dist = Math.sqrt((a * a) + (b * b)).toFixed(2);

                // If the two particles are in proximity, join them
                if (dist < options.proximity) {
                    ctx.moveTo(this.position.x + this.parallaxOffsetX, this.position.y + this.parallaxOffsetY);
                    if (options.curvedLines) {
                        ctx.quadraticCurveTo(Math.max(p2.position.x, p2.position.x), Math.min(p2.position.y, p2.position.y), p2.position.x + p2.parallaxOffsetX, p2.position.y + p2.parallaxOffsetY);
                    } else {
                        ctx.lineTo(p2.position.x + p2.parallaxOffsetX, p2.position.y + p2.parallaxOffsetY);
                    }
                }
            }
            ctx.stroke();
            ctx.closePath();
        }

        /**
         * update particle position
         */
        Particle.prototype.updatePosition = function() {
            if (options.parallax) {
                if (orientationSupport && !desktop) {
                    // Map tiltX range [-30,30] to range [0,winW]
                    var ratioX = (winW - 0) / (30 - -30);
                    pointerX = (tiltX - -30) * ratioX + 0;
                    // Map tiltY range [-30,30] to range [0,winH]
                    var ratioY = (winH - 0) / (30 - -30);
                    pointerY = (tiltY - -30) * ratioY + 0;
                } else {
                    pointerX = mouseX;
                    pointerY = mouseY;
                }
                // Calculate parallax offsets
                this.parallaxTargX = (pointerX - (winW / 2)) / (options.parallaxMultiplier * this.layer);
                this.parallaxOffsetX += (this.parallaxTargX - this.parallaxOffsetX) / 10; // Easing equation
                this.parallaxTargY = (pointerY - (winH / 2)) / (options.parallaxMultiplier * this.layer);
                this.parallaxOffsetY += (this.parallaxTargY - this.parallaxOffsetY) / 10; // Easing equation
            }

            var elWidth = element.offsetWidth;
            var elHeight = element.offsetHeight;

            switch (options.directionX) {
                case 'left':
                    if (this.position.x + this.speed.x + this.parallaxOffsetX < 0) {
                        this.position.x = elWidth - this.parallaxOffsetX;
                    }
                    break;
                case 'right':
                    if (this.position.x + this.speed.x + this.parallaxOffsetX > elWidth) {
                        this.position.x = 0 - this.parallaxOffsetX;
                    }
                    break;
                default:
                    // If particle has reached edge of canvas, reverse its direction
                    if (this.position.x + this.speed.x + this.parallaxOffsetX > elWidth || this.position.x + this.speed.x + this.parallaxOffsetX < 0) {
                        this.speed.x = -this.speed.x;
                    }
                    break;
            }

            switch (options.directionY) {
                case 'up':
                    if (this.position.y + this.speed.y + this.parallaxOffsetY < 0) {
                        this.position.y = elHeight - this.parallaxOffsetY;
                    }
                    break;
                case 'down':
                    if (this.position.y + this.speed.y + this.parallaxOffsetY > elHeight) {
                        this.position.y = 0 - this.parallaxOffsetY;
                    }
                    break;
                default:
                    // If particle has reached edge of canvas, reverse its direction
                    if (this.position.y + this.speed.y + this.parallaxOffsetY > elHeight || this.position.y + this.speed.y + this.parallaxOffsetY < 0) {
                        this.speed.y = -this.speed.y;
                    }
                    break;
            }

            // Move particle
            this.position.x += this.speed.x;
            this.position.y += this.speed.y;
        }

        /**
         * Setter: particle stacking position
         */
        Particle.prototype.setStackPos = function(i) {
            this.stackPos = i;
        }

        function option(key, val) {
            if (val) {
                options[key] = val;
            } else {
                return options[key];
            }
        }

        function destroy() {
            console.log('destroy');
            canvas.parentNode.removeChild(canvas);
            hook('onDestroy');
            if ($) {
                $(element).removeData('plugin_' + pluginName);
            }
        }

        function hook(hookName) {
            if (options[hookName] !== undefined) {
                options[hookName].call(element);
            }
        }

        init();

        return {
            option: option,
            destroy: destroy,
            start: start,
            pause: pause
        };
    }

    window[pluginName] = function(elem, options) {
        return new Plugin(elem, options);
    };

    window[pluginName].defaults = {
        minSpeedX: 0.1,
        maxSpeedX: 0.7,
        minSpeedY: 0.1,
        maxSpeedY: 0.7,
        directionX: 'center', // 'center', 'left' or 'right'. 'center' = dots bounce off edges
        directionY: 'center', // 'center', 'up' or 'down'. 'center' = dots bounce off edges
        density: 10000, // How many particles will be generated: one particle every n pixels
        dotColor: '#666666',
        lineColor: '#666666',
        particleRadius: 7, // Dot size
        lineWidth: 1,
        curvedLines: false,
        proximity: 100, // How close two dots need to be before they join
        parallax: true,
        parallaxMultiplier: 5, // The lower the number, the more extreme the parallax effect
        onInit: function() {},
        onDestroy: function() {}
    };

    // nothing wrong with hooking into jQuery if it's there...
    if ($) {
        $.fn[pluginName] = function(options) {
            if (typeof arguments[0] === 'string') {
                var methodName = arguments[0];
                var args = Array.prototype.slice.call(arguments, 1);
                var returnVal;
                this.each(function() {
                    if ($.data(this, 'plugin_' + pluginName) && typeof $.data(this, 'plugin_' + pluginName)[methodName] === 'function') {
                        returnVal = $.data(this, 'plugin_' + pluginName)[methodName].apply(this, args);
                    }
                });
                if (returnVal !== undefined) {
                    return returnVal;
                } else {
                    return this;
                }
            } else if (typeof options === "object" || !options) {
                return this.each(function() {
                    if (!$.data(this, 'plugin_' + pluginName)) {
                        $.data(this, 'plugin_' + pluginName, new Plugin(this, options));
                    }
                });
            }
        };
    }

})(window, document);

(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
            window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());
    const preload = () => {

let manager = new THREE.LoadingManager();
manager.onLoad = function() { 
  const environment = new Environment( typo, particle );
}

var typo = null;
const loader = new THREE.FontLoader( manager );
const font = loader.load('https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json', function ( font ) { typo = font; });
const particle = new THREE.TextureLoader( manager ).load( 'https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png');

}

if ( document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll))
preload ();
else
document.addEventListener("DOMContentLoaded", preload ); 

class Environment {

constructor( font, particle ){ 

  this.font = font;
  this.particle = particle;
  this.container = document.querySelector( '#magic' );
  this.scene = new THREE.Scene();
  this.createCamera();
  this.createRenderer();
  this.setup()
  this.bindEvents();
}

bindEvents(){

  window.addEventListener( 'resize', this.onWindowResize.bind( this ));
  
}

setup(){ 

  this.createParticles = new CreateParticles( this.scene, this.font,             this.particle, this.camera, this.renderer );
}

render() {
  
   this.createParticles.render()
   this.renderer.render( this.scene, this.camera )
}

createCamera() {

  this.camera = new THREE.PerspectiveCamera( 65, this.container.clientWidth /  this.container.clientHeight, 1, 10000 );
  this.camera.position.set( 0,0, 100 );

}

createRenderer() {

  this.renderer = new THREE.WebGLRenderer();
  this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );

  this.renderer.setPixelRatio( Math.min( window.devicePixelRatio, 2));

  this.renderer.outputEncoding = THREE.sRGBEncoding;
  this.container.appendChild( this.renderer.domElement );

  this.renderer.setAnimationLoop(() => { this.render() })

}

onWindowResize(){

  this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
  this.camera.updateProjectionMatrix();
  this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );

}
}

class CreateParticles {
  
  constructor( scene, font, particleImg, camera, renderer ) {
  
      this.scene = scene;
      this.font = font;
      this.particleImg = particleImg;
      this.camera = camera;
      this.renderer = renderer;
      
      this.raycaster = new THREE.Raycaster();
      this.mouse = new THREE.Vector2(-200, 200);
      
      this.colorChange = new THREE.Color();

      this.buttom = false;

      this.data = {

          text: "TECHNOTSAV'24",
          amount: 1500,
          particleSize: 1,
          particleColor: 0xffffff,
          textSize: 12,
          area: 250,
          ease: .05,
      }

      this.setup();
      this.bindEvents();

  }


  setup(){

      const geometry = new THREE.PlaneGeometry( this.visibleWidthAtZDepth( 100, this.camera ), this.visibleHeightAtZDepth( 100, this.camera ));
      const material = new THREE.MeshBasicMaterial( { color: 0x00ff00, transparent: true } );
      this.planeArea = new THREE.Mesh( geometry, material );
      this.planeArea.visible = false;
      this.createText();

  }

  bindEvents() {

      document.addEventListener( 'mousedown', this.onMouseDown.bind( this ));
      document.addEventListener( 'mousemove', this.onMouseMove.bind( this ));
      document.addEventListener( 'mouseup', this.onMouseUp.bind( this ));
      
  }

  onMouseDown(){
      
      this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      const vector = new THREE.Vector3( this.mouse.x, this.mouse.y, 0.5);
      vector.unproject( this.camera );
      const dir = vector.sub( this.camera.position ).normalize();
      const distance = - this.camera.position.z / dir.z;
      this.currenPosition = this.camera.position.clone().add( dir.multiplyScalar( distance ) );
      
      const pos = this.particles.geometry.attributes.position;
      this.buttom = true;
      this.data.ease = .01;
      
  }

  onMouseUp(){

      this.buttom = false;
      this.data.ease = .05;
  }

  onMouseMove( ) { 

      this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
      this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      const vector = new THREE.Vector3( this.mouse.x, this.mouse.y, 0.5);
      vector.unproject( this.camera );
      const dir = vector.sub( this.camera.position ).normalize();
      const distance = - this.camera.position.z / dir.z;
      this.currenPosition = this.camera.position.clone().add( dir.multiplyScalar( distance ) );
      
      const pos = this.particles.geometry.attributes.position;
      this.buttom = true;
      this.data.ease = .01;

  }

  render( level ){ 

      const time = ((.001 * performance.now())%12)/12;
      const zigzagTime = (1 + (Math.sin( time * 2 * Math.PI )))/6;

      this.raycaster.setFromCamera( this.mouse, this.camera );

      const intersects = this.raycaster.intersectObject( this.planeArea );

      if ( intersects.length > 0 ) {

          const pos = this.particles.geometry.attributes.position;
          const copy = this.geometryCopy.attributes.position;
          const coulors = this.particles.geometry.attributes.customColor;
          const size = this.particles.geometry.attributes.size;

          const mx = intersects[ 0 ].point.x;
          const my = intersects[ 0 ].point.y;
          const mz = intersects[ 0 ].point.z;

          for ( var i = 0, l = pos.count; i < l; i++) {

              const initX = copy.getX(i);
              const initY = copy.getY(i);
              const initZ = copy.getZ(i);

              let px = pos.getX(i);
              let py = pos.getY(i);
              let pz = pos.getZ(i);

              this.colorChange.setHSL( .5, 1 , 1 )
              coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
              coulors.needsUpdate = true;

              size.array[ i ]  = this.data.particleSize;
              size.needsUpdate = true;

              let dx = mx - px;
              let dy = my - py;
              const dz = mz - pz;

              const mouseDistance = this.distance( mx, my, px, py )
              let d = ( dx = mx - px ) * dx + ( dy = my - py ) * dy;
              const f = - this.data.area/d;

              if( this.buttom ){ 

                  const t = Math.atan2( dy, dx );
                  px -= f * Math.cos( t );
                  py -= f * Math.sin( t );

                  this.colorChange.setHSL( .5 + zigzagTime, 1.0 , .5 )
                  coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                  coulors.needsUpdate = true;

                  if ((px > (initX + 70)) || ( px < (initX - 70)) || (py > (initY + 70) || ( py < (initY - 70)))){

                      this.colorChange.setHSL( .15, 1.0 , .5 )
                      coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                      coulors.needsUpdate = true;

                  }

              }else{
              
                  if( mouseDistance < this.data.area ){

                      if(i%5==0){

                          const t = Math.atan2( dy, dx );
                          px -= .03 * Math.cos( t );
                          py -= .03 * Math.sin( t );

                          this.colorChange.setHSL( .15 , 1.0 , .5 )
                          coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                          coulors.needsUpdate = true;

                          size.array[ i ]  =  this.data.particleSize /1.2;
                          size.needsUpdate = true;

                      }else{

                          const t = Math.atan2( dy, dx );
                          px += f * Math.cos( t );
                          py += f * Math.sin( t );

                          pos.setXYZ( i, px, py, pz );
                          pos.needsUpdate = true;

                          size.array[ i ]  = this.data.particleSize * 1.3 ;
                          size.needsUpdate = true;
                      }

                      if ((px > (initX + 10)) || ( px < (initX - 10)) || (py > (initY + 10) || ( py < (initY - 10)))){

                          this.colorChange.setHSL( .15, 1.0 , .5 )
                          coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                          coulors.needsUpdate = true;

                          size.array[ i ]  = this.data.particleSize /1.8;
                          size.needsUpdate = true;

                      }
                  }

              }

              px += ( initX  - px ) * this.data.ease;
              py += ( initY  - py ) * this.data.ease;
              pz += ( initZ  - pz ) * this.data.ease;

              pos.setXYZ( i, px, py, pz );
              pos.needsUpdate = true;

          }
      }
  }

  createText(){ 

      let thePoints = [];

      let shapes = this.font.generateShapes( this.data.text , this.data.textSize  );
      let geometry = new THREE.ShapeGeometry( shapes );
      geometry.computeBoundingBox();
  
      const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
      const yMid =  (geometry.boundingBox.max.y - geometry.boundingBox.min.y)/2.85;

      geometry.center();

      let holeShapes = [];

      for ( let q = 0; q < shapes.length; q ++ ) {

          let shape = shapes[ q ];

          if ( shape.holes && shape.holes.length > 0 ) {

              for ( let  j = 0; j < shape.holes.length; j ++ ) {

                  let  hole = shape.holes[ j ];
                  holeShapes.push( hole );
              }
          }

      }
      shapes.push.apply( shapes, holeShapes );

      let colors = [];
      let sizes = [];
                  
      for ( let  x = 0; x < shapes.length; x ++ ) {

          let shape = shapes[ x ];

          const amountPoints = ( shape.type == 'Path') ? this.data.amount/2 : this.data.amount;

          let points = shape.getSpacedPoints( amountPoints ) ;

          points.forEach( ( element, z ) => {
                      
              const a = new THREE.Vector3( element.x, element.y, 0 );
              thePoints.push( a );
              colors.push( this.colorChange.r, this.colorChange.g, this.colorChange.b);
              sizes.push( 1 )

              });
      }

      let geoParticles = new THREE.BufferGeometry().setFromPoints( thePoints );
      geoParticles.translate( xMid, yMid, 0 );
              
      geoParticles.setAttribute( 'customColor', new THREE.Float32BufferAttribute( colors, 3 ) );
      geoParticles.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1) );

      const material = new THREE.ShaderMaterial( {

          uniforms: {
              color: { value: new THREE.Color( 0xffffff ) },
              pointTexture: { value: this.particleImg }
          },
          vertexShader: document.getElementById( 'vertexshader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
      } );

      this.particles = new THREE.Points( geoParticles, material );
      this.scene.add( this.particles );

      this.geometryCopy = new THREE.BufferGeometry();
      this.geometryCopy.copy( this.particles.geometry );
      
  }

  visibleHeightAtZDepth ( depth, camera ) {

    const cameraOffset = camera.position.z;
    if ( depth < cameraOffset ) depth -= cameraOffset;
    else depth += cameraOffset;

    const vFOV = camera.fov * Math.PI / 180; 

    return 2 * Math.tan( vFOV / 2 ) * Math.abs( depth );
  }

  visibleWidthAtZDepth( depth, camera ) {

    const height = this.visibleHeightAtZDepth( depth, camera );
    return height * camera.aspect;

  }

  distance (x1, y1, x2, y2){
     
      return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));
  }
}

  </script>
  <script></script>
</body>
</html>
